import { BrowserRouter } from 'react-router-dom';
import { screen } from '@testing-library/react';
import { rest } from 'msw'
import { setupServer } from 'msw/node'

import { renderWithProviders } from '../../../../test_utils/test-utils';
import BlogDetail from '../BlogDetail';

// mocking useParams hook of react router
jest.mock('react-router-dom', () => ({
  ...jest.requireActual('react-router-dom'),
  useParams: () => ({
    blogId: '637bdc110aad625444dc19e1',
  })
}));

// We use msw to intercept the network request during the test,
// and return the response blog data after 150ms
// when receiving a get request to the `/blogs/:id` endpoint
export const handlers = [
  rest.get('/api/v1/blogs/:id', (req, res, ctx) => {

    return res(ctx.json({
      "status": "success",
      "data": {
        "ratingsAverage": 4.5,
        "ratingsQuantity": 0,
        "images": [
          "blog-1.jpg"
        ],
        "createdAt": "2022-11-21T20:13:54.365Z",
        "category": "Web development",
        "comments": 0,
        "_id": "637bdc110aad625444dc19e1",
        "title": "JavaScript Objects in Detail",
        "description": "&lt;p>JavaScript's core—most often used and most fundamental—data type is the Object data type. JavaScript has one complex data type, the Object data type, and it has five simple data types: Number, String, Boolean, Undefined, and Null. Note that these simple (primitive) data types are immutable (cannot be changed), while objects are mutable (can be changed).&lt;/p>&lt;p>&lt;strong>What is an Object&lt;/strong>&lt;br>An object is an unordered list of primitive data types (and sometimes reference data types) that is stored as a series of name-value pairs. Each item in the list is called a &lt;em>property&lt;/em> (functions are called &lt;em>methods&lt;/em>).&lt;/p>&lt;p>Consider this simple object:&lt;/p>&lt;pre>&lt;code data-language=\"javascript\">var myFirstObject = {firstName: \"Richard\", favoriteAuthor: \"Conrad\"};&lt;/code>&lt;/pre>&lt;p>Think of an object as a list that contains items, and each item (a property or a method) in the list is stored by a name-value pair. The property names in the example above are firstName and favoriteAuthor. And the values are “Richard” and “Conrad.”&lt;/p>&lt;p>&lt;br>Property names can be a string or a number, but if the property name is a number, it has to be accessed with the bracket notation. More on bracket notation later. Here is another example of objects with numbers as the property name:&lt;/p>&lt;pre>&lt;code data-language=\"javascript\"> var ageGroup = {30: \"Children\", 100:\"Very Old\"};&lt;br>console.log(ageGroup.30) // This will throw an error&lt;br>// This is how you will access the value of the property 30, to get value \"Children\"console.log(ageGroup[\"30\"]); &lt;br>// Children//It is best to avoid using numbers as property names.&lt;/code>&lt;/pre>&lt;p>As a JavaScript developer you will most often use the object data type, mostly for storing data and for creating your own custom methods and functions.&lt;/p>&lt;p>&lt;strong>Reference Data Type and Primitive Data Types&lt;/strong>&lt;br>One of the main differences between reference data type and primitive data types is reference data type's value is stored as a reference, it is not stored directly on the variable, as a value, as the primitive data types are. For example:&lt;/p>&lt;pre>&lt;code data-language=\"javascript\">// The primitive data type String is stored as a value&lt;br>var person = \"Kobe\";  &lt;br>var anotherPerson = person; // anotherPerson = the value of person&lt;br>person = \"Bryant\"; // value of person changed&lt;br>console.log(anotherPerson); // Kobe&lt;br>console.log(person); // Bryant&lt;/code>&lt;/pre>&lt;p>It is worth noting that even though we changed &lt;em>person&lt;/em> to “Bryant,” the &lt;em>anotherPerson&lt;/em> variable still retains the value that person had.&lt;/p>&lt;p>Compare the primitive data saved-as-value demonstrated above with the save-as-reference for objects:&lt;/p>&lt;pre>&lt;code data-language=\"javascript\">var person = {name: \"Kobe\"};&lt;br>var anotherPerson = person;&lt;br>person.name = \"Bryant\";&lt;br>console.log(anotherPerson.name); // Bryant&lt;br>console.log(person.name); // Bryant&lt;/code>&lt;/pre>&lt;p>In this example, we copied the &lt;em>person&lt;/em> object to &lt;em>anotherPerson&lt;/em>, but because the value in person was stored as a reference and not an actual value, when we changed the person.name property to “Bryant” the anotherPerson reflected the change because it never stored an actual copy of it's own value of the person's properties, it only had a reference to it.&lt;/p>&lt;p>&lt;strong>Object Data Properties Have Attributes&lt;/strong>&lt;br>Each data property (object property that store data) has not only the name-value pair, but also 3 attributes (the three attributes are set to true by default):&lt;br>&lt;strong>— Configurable Attribute:&lt;/strong> Specifies whether the property can be deleted or changed.&lt;br>&lt;strong>— Enumerable: &lt;/strong>Specifies whether the property can be returned in a for/in loop.&lt;br>&lt;strong>— Writable: &lt;/strong>Specifies whether the property can be changed.&lt;/p>&lt;p>Note that ECMAScript 5 specifies accessor properties along with the data properties noted above. And the accessor properties are functions (getters and setters).&lt;/p>&lt;p>&lt;strong>Creating Objects&lt;/strong>&lt;br>These are the two common ways to create objects:&lt;/p>&lt;ol>&lt;li>&lt;strong>Object Literals&lt;/strong>&lt;br>The most common and, indeed, the easiest way to create objects is with the object literal described here:&lt;pre>&lt;code data-language=\"javascript\">// This is an empty object initialized using the object literal notation&lt;br>var myBooks = {};// This is an object with 4 items, again using object literal&lt;br>&lt;/code>var mango = {&lt;br>    color: \"yellow\",&lt;br>    shape: \"round\",&lt;br>    sweetness: 8,&lt;br>    howSweetAmI: function() {&lt;br>        console.log(\"Hmm Hmm Good\");&lt;br>    }&lt;br>}&lt;br>&lt;/pre>&lt;/li>&lt;li>&lt;strong>Object Constructor&lt;/strong>&lt;br>The second most common way to create objects is with Object constructor.  A constructor is a function used for initializing new objects, and you use the new keyword to call the constructor.&lt;pre>var mango = new Object();&lt;br>mango.color = \"yellow\";&lt;br>mango.shape = \"round\";&lt;br>mango.sweetness = 8;&lt;br>mango.howSweetAmI = function() {&lt;br>    console.log(\"Hmm Hmm Good\");&lt;br>}&lt;br>&lt;/pre>&lt;/li>&lt;/ol>&lt;p>While you can use some reserved word such as “for” as property names in your objects, it is wise to avoid this altogether.&lt;/p>&lt;p>Objects can contain any other data type, including Numbers, Arrays, and even other Objects.&lt;/p>&lt;p>&lt;strong>Practical Patterns for Creating Objects&lt;/strong>&lt;br>For simple objects that may only ever be used once in your application to store data, the two methods used above would suffice for creating objects.&lt;/p>&lt;p>Imagine you have an application that displays fruits and detail about each fruit. All fruits in your application have these properties: color, shape, sweetness, cost, and a showName function. It would be quite tedious and counterproductive to type the following every time you want to create a new fruit object.&lt;/p>&lt;pre>&lt;code data-language=\"javascript\">var mangoFruit = {&lt;br>&nbsp;&nbsp;&nbsp;&nbsp;color: \"yellow\",&lt;br>&nbsp;&nbsp;&nbsp;&nbsp;sweetness: 8,&lt;br>&nbsp;&nbsp;&nbsp;&nbsp;fruitName: \"Mango\",&lt;br>&nbsp;&nbsp;&nbsp;&nbsp;nativeToLand: [\"South America\", \"Central America\"],&lt;br>&nbsp;&nbsp;&nbsp;&nbsp;showName: function () {&lt;br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(\"This is \" + this.fruitName);&lt;br>&nbsp;&nbsp;&nbsp;&nbsp;},&lt;br>&nbsp;&nbsp;&nbsp;&nbsp;nativeTo: function () {&lt;br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.nativeToLand.forEach(function (eachCountry)  {&lt;br>            console.log(\"Grown in:\" + eachCountry);        &lt;br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});&lt;br>&nbsp;&nbsp;&nbsp;&nbsp;}&lt;br>}&lt;/code>&lt;/pre>&lt;p>If you have 10 fruits, you will have to add the &lt;strong>same&lt;/strong> code 10 times. And what if you had to make a change to the nativeTo function? You will have to make the change in 10 different places. Now extrapolate this to adding objects for members on a website and suddenly you realized the manner in which we have created objects so far is not ideal objects that will have instances, particularly when developing large applications.&lt;/p>&lt;p>To solve these repetitive problems, software engineers have invented patterns (solutions for repetitive and common tasks) to make developing applications more efficient and streamlined.&lt;/p>&lt;p>Here are two common patterns for creating objects. If you have done the Learn JavaScript Properly course, you would have seen the lessons in the Code Academy used this first pattern frequently:&lt;/p>&lt;ol>&lt;li>&lt;strong>Constructor Pattern for Creating Objects&lt;/strong>&lt;pre>function Fruit(theColor, theSweetness, theFruitName, theNativeToLand) {\n    this.color = theColor;\n    this.sweetness = theSweetness;\n    this.fruitName = theFruitName;\n    this.nativeToLand = theNativeToLand;\n    this.showName = function() {\n        console.log(\"This is a \" + this.fruitName);\n    }\n    this.nativeTo = function() {\n        this.nativeToLand.forEach(function(eachCountry) {\n            console.log(\"Grown in:\" + eachCountry);\n        });\n    }&lt;br>}&lt;br>&lt;/pre>&lt;p>With this pattern in place, it is very easy to create all sorts of fruits. Thus:&lt;/p>&lt;pre>&lt;code data-language=\"javascript\">var mangoFruit = new Fruit (\"Yellow\", 8, \"Mango\", [\"South America\", \"Central America\", \"West Africa\"]);&lt;br>mangoFruit.showName(); // This is a Mango.&lt;br>mangoFruit.nativeTo();&lt;br>//Grown in:South America&lt;br>// Grown in:Central America&lt;br>// Grown in:West Africa&lt;br>var pineappleFruit = new Fruit (\"Brown\", 5, \"Pineapple\", [\"United States\"]);&lt;br>pineappleFruit.showName(); // This is a Pineapple.&lt;/code>&lt;/pre>&lt;p>If you had to change the fruitName function, you only had to do it in one location. The pattern encapsulates all the functionalities and characteristics of all the fruits in by making just the single Fruit function with inheritance.&lt;/p>&lt;p>Notes:&lt;br>— An inherited property is defined on the object's prototype property. For example: someObject.prototype.firstName = “rich”;&lt;/p>&lt;p>— An own property is defined directly on the object itself, for example:&lt;br>// Let's create an object first:&lt;br>var aMango = new Fruit ();&lt;br>// Now we define the mangoSpice property directly on the aMango object&lt;br>// Because we define the mangoSpice property directly on the aMango object, it is an own property of aMango, not an inherited property.&lt;br>aMango.mangoSpice = “some value”;&lt;/p>&lt;p>— To access a property of an object, we use object.property, for example:&lt;br>console.log(aMango.mangoSpice); // “some value”&lt;/p>&lt;p>— To invoke a method of an object, we use object.method(), for example:&lt;br>// First, lets add a method&lt;br>aMango.printStuff = function () {return “Printing”;}&lt;/p>&lt;p>// Now we can invoke the printStuff method:&lt;br>aMango.printStuff ();&lt;/p>&lt;/li>&lt;li> &lt;strong>Prototype Pattern for Creating Objects&lt;/strong>&lt;pre>function Fruit() {}&lt;br>Fruit.prototype.color = \"Yellow\";&lt;br>Fruit.prototype.sweetness = 7;&lt;br>Fruit.prototype.fruitName = \"Generic Fruit\";&lt;br>Fruit.prototype.nativeToLand = \"USA\";&lt;br>Fruit.prototype.showName = function() {&lt;br>    console.log(\"This is a \" + this.fruitName);&lt;br>}\n&lt;br>Fruit.prototype.nativeTo = function() {&lt;br>    console.log(\"Grown in:\" + this.nativeToLand);&lt;br>}&lt;br>&lt;/pre>&lt;p>And this is how we call the Fruit () constructor in this prototype pattern: &lt;/p>&lt;pre>&lt;code data-language=\"javascript\">var mangoFruit = new Fruit ();&lt;br>mangoFruit.showName(); //&lt;br>mangoFruit.nativeTo();&lt;br>// This is a Generic Fruit&lt;br>// Grown in:USA&lt;/code>&lt;/pre>&lt;/li>&lt;/ol>&lt;p>&lt;strong>Further Reading&lt;/strong>&lt;br>For a complete discussion on these two patterns and a thorough explanation of how each work and the disadvantages of each, read Chapter 6 of &lt;em>Professional JavaScript for Web Developers&lt;/em>. You will also learn which pattern Zakas recommends as the best one to use (Hint: it is neither of the 2 above).&lt;/p>&lt;p>&lt;strong>How to Access Properties on an Object&lt;/strong>&lt;br>The two primary ways of accessing properties of an object are with dot notation and bracket notation.&lt;/p>&lt;ol>&lt;li>&lt;strong>Dot Notation&lt;/strong>&lt;pre>&lt;code data-language=\"javascript\">// We have been using dot notation so far in the examples above, here is another example again:&lt;br>var book = {title: \"Ways to Go\", pages: 280, bookMark1:\"Page 20\"};&lt;br>// To access the properties of the book object with dot notation, you do this:&lt;br>console.log ( book.title); // Ways to Go&lt;br>console.log ( book.pages); // 280&lt;/code>&lt;/pre>&lt;/li>&lt;li>&lt;strong> Bracket Notation&lt;/strong>&lt;pre>&lt;code data-language=\"javascript\">// To access the properties of the book object with bracket notation, you do this:&lt;br>console.log ( book[\"title\"]); //Ways to Go&lt;br>console.log ( book[\"pages\"]); // 280&lt;br>//Or, in case you have the property name in a variable:&lt;br>var bookTitle = \"title\";&lt;br>console.log ( book[bookTitle]); // Ways to Go&lt;br>console.log (book[\"bookMark\" + 1]); // Page 20&lt;/code>&lt;/pre>&lt;/li>&lt;/ol>&lt;p>Accessing a property on an object that does not exist will result in &lt;em>undefined&lt;/em>.&lt;/p>&lt;p>&lt;strong>Own and Inherited Properties&lt;/strong>&lt;br>Objects have inherited properties and own properties. The own properties are properties that were defined on the object, while the inherited properties were inherited from the object's Prototype object.&lt;/p>&lt;p>To find out if a property exists on an object (either as an inherited or an own property), you use the in operator:&lt;/p>&lt;pre>&lt;code data-language=\"javascript\">// Create a new school object with a property name schoolNamevar school = {schoolName:\"MIT\"};// Prints true because schoolName is an own property on the school objectconsole.log(\"schoolName\" in school);  // true// Prints false because we did not define a schoolType property on the school object, and neither did the object inherit a schoolType property from its prototype object Object.prototype.console.log(\"schoolType\" in school);  // false // Prints true because the school object inherited the toString method from Object.prototype. console.log(\"toString\" in school);  // true&lt;/code>&lt;/pre>&lt;p>&lt;strong>hasOwnProperty&lt;/strong>&lt;br>To find out if an object has a specific property as one of its own property, you use the hasOwnProperty method. This method is very useful because from time to time you need to enumerate an object and you want only the own properties, not the inherited ones.&lt;/p>&lt;pre>&lt;code data-language=\"javascript\">// Create a new school object with a property name schoolName&lt;br>var school = {schoolName:\"MIT\"};// Prints true because schoolName is an own property on the school object&lt;br>console.log(school.hasOwnProperty (\"schoolName\"));  &lt;br>// true &lt;br>// Prints false because the school object inherited the toString method from Object.prototype, therefore toString is not an own property of the school object.console.log(school.hasOwnProperty (\"toString\"));  // false &lt;/code>&lt;/pre>&lt;p>&lt;strong>Accessing and Enumerating Properties on Objects&lt;/strong>&lt;br>To access the enumerable (own and inherited) properties on objects, you use the for/in loop or a general for loop.&lt;/p>&lt;pre>&lt;code data-language=\"javascript\">// Create a new school object with 3 own properties: schoolName, schoolAccredited, and schoolLocation.&lt;br>var school = {schoolName:\"MIT\", schoolAccredited: true, schoolLocation:\"Massachusetts\"};&lt;br>//Use of the for/in loop to access the properties in the school object&lt;br>for (var eachItem in school) {console.log(eachItem); // Prints schoolName, schoolAccredited, schoolLocation}&lt;/code>&lt;/pre>&lt;p>&lt;strong>Accessing Inherited Properties&lt;/strong>&lt;br>Properties inherited from Object.prototype are not enumerable, so the for/in loop does not show them. However, inherited properties that are enumerable are revealed in the for/in loop iteration.&lt;br>For example:&lt;/p>&lt;pre>&lt;code data-language=\"javascript\"> //Use of the for/in loop to access the properties in the school object&lt;br>for (var eachItem in school) {&lt;br>console.log(eachItem); // Prints schoolName, schoolAccredited, schoolLocation}&lt;br>// Create a new HigherLearning function that the school object will inherit from.&lt;br>/* SIDE NOTE: As Wilson (an astute reader) correctly pointed out in the comments below, the educationLevel property is not actually inherited by objects that use the HigherLearning constructor; instead, the educationLevel property is created as a new property on each object that uses the HigherLearning constructor. The reason the property is not inherited is because we use of the \"this\" keyword to define the property.*/&lt;br>&lt;br>function HigherLearning () {&lt;br>&nbsp;&nbsp;&nbsp;&nbsp;this.educationLevel = \"University\";&lt;br>}&lt;br>// Implement inheritance with the HigherLearning constructor&lt;br>var school = new HigherLearning ();&lt;br>school.schoolName = \"MIT\";&lt;br>school.schoolAccredited = true;&lt;br>school.schoolLocation = \"Massachusetts\";&lt;br>//Use of the for/in loop to access the properties in the school object&lt;br>for (var eachItem in school) {&lt;br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(eachItem); // Prints educationLevel, schoolName, schoolAccredited, and schoolLocation&lt;br>}&lt;/code>&lt;/pre>&lt;p>In the last example, note the educationLevel property that was defined on the HigherLearning function is listed as one of the school's properties, even though educationLevel is not an own property—it was inherited.&lt;/p>&lt;p>&lt;strong>Object's Prototype Attribute and Prototype Property&lt;/strong>&lt;br>The prototype attribute and prototype property of an object are critically important concepts to understand in JavaScript. Read my post &lt;a href=\"http://javascriptissexy.com/javascript-prototype-in-plain-detailed-language/\">JavaScript Prototype in Plain, Detailed Language&lt;/a> for more.&lt;/p>&lt;p>&lt;strong>Deleting Properties of an Object&lt;/strong>&lt;br>To delete a property from an object, you use the delete operator. You cannot delete properties that were inherited, nor can you delete properties with their attributes set to configurable. You must delete the inherited properties on the prototype object (where the properties were defined). Also, you cannot delete properties of the global object, which were declared with the var keyword.&lt;/p>&lt;p>The delete operator returns true if the delete was successful. And surprisingly, it also returns true if the property to delete was nonexistent or the property could not be deleted (such as non-configurable or not owned by the object).&lt;/p>&lt;p>These examples illustrate:&lt;/p>&lt;pre>&lt;code data-language=\"javascript\">var christmasList = {mike:\"Book\", jason:\"sweater\" }&lt;br>delete christmasList.mike; // deletes the mike property&lt;br>for (var people in christmasList) {&lt;br>    console.log(people);&lt;br>}&lt;br>// Prints only jason&lt;br>// The mike property was deleted&lt;br>delete christmasList.toString; // returns true, but toString not deleted because it is an inherited method&lt;br>// Here we call the toString method and it works just fine—wasn't deleted &lt;br>christmasList.toString(); //\"[object Object]\"&lt;br>// You can delete a property of an instance if the property is an own property of that instance. For example, we can delete the educationLevel property from the school's object we created above because the educationLevel property is defined on the instance: we used the \"this\" keyword to define the property when we declare the HigherLearning function. We did not define the educationLevel property on the HigherLearning function's prototype.&lt;br>&lt;br>console.log(school.hasOwnProperty(\"educationLevel\")); true&lt;br>// educationLevel is an own property on school, so we can delete it&lt;br>delete school.educationLevel; true &lt;br>// The educationLevel property was deleted from the school instance&lt;br>console.log(school.educationLevel); undefined&lt;br>// But the educationLevel property is still on the HigherLearning function&lt;br>var newSchool = new HigherLearning ();&lt;br>console.log(newSchool.educationLevel); // University&lt;br>// If we had defined a property on the HigherLearning function's prototype, such as this educationLevel2 property:&lt;br>HigherLearning.prototype.educationLevel2 = \"University 2\";&lt;br>// Then the educationLevel2 property on the instances of HigherLearning would not be own property. &lt;br>// The educationLevel2 property is not an own property on the school instance&lt;br>console.log(school.hasOwnProperty(\"educationLevel2\")); false&lt;br>console.log(school.educationLevel2); // University 2&lt;br>// Let's try to delete the inherited educationLevel2 property&lt;br>delete school.educationLevel2; true (always returns true, as noted earlier)&lt;br>// The inherited educationLevel2 property was not deleted&lt;br>console.log(school.educationLevel2); University 2&lt;/code>&lt;/pre>&lt;p>&lt;strong>Serialize and Deserialize Objects&lt;/strong>&lt;br>To transfer your objects via HTTP or to otherwise convert it to a string, you will need to serialize it (convert it to a string); you can use the JSON.stringify  function to serialize your objects. Note that prior to ECMAScript 5, you had to use a popular json2 library (by Douglas Crockford) to get the JSON.stringify function. It is now standardized in ECMAScript 5.&lt;/p>&lt;p>To Deserialize your object (convert it to an object from a string), you use the JSON.parse function from the same json2 library. This function too has been standardized by ECMAScript 5.&lt;/p>&lt;p>JSON.stringify Examples:&lt;/p>&lt;pre>&lt;code data-language=\"javascript\">var christmasList = {mike:\"Book\", jason:\"sweater\", chelsea:\"iPad\" }&lt;br>JSON.stringify (christmasList);&lt;br>// Prints this string:&lt;br>// \"{\"mike\":\"Book\",\"jason\":\"sweater\",\"chels\":\"iPad\"}\"&lt;br>// To print a stringified object with formatting, add \"null\" and \"4\" as parameters:&lt;br>JSON.stringify (christmasList, null, 4);&lt;br>// \"{    \"mike\": \"Book\",    \"jason\": \"sweater\",    \"chels\": \"iPad\"}\"&lt;br>// JSON.parse Examples \\\\\\\\&lt;br>// The following is a JSON string, so we cannot access the properties with dot notation (like christmasListStr.mike)&lt;br>var christmasListStr = '{\"mike\":\"Book\",\"jason\":\"sweater\",\"chels\":\"iPad\"}';&lt;br>// Let's convert it to an object&lt;br>var christmasListObj = JSON.parse (christmasListStr); &lt;br>// Now that it is an object, we use dot notation&lt;br>console.log(christmasListObj.mike); // Book&lt;/code>&lt;/pre>&lt;p>&lt;br>&lt;/p>&lt;p>`&lt;/p>",
        "user": {
          "photo": "default.jpg",
          "_id": "637bd75954f97f42e88ec68d",
          "name": "Sumanta Mukherjee"
        },
        "slug": "javascript-objects-in-detail",
        "__v": 0,
        "shortDescription": "&lt;p>JavaScript's core—most often used and most fundamental—data type is the Object data type. JavaScript has one complex data type, the Object data type, and it has five simple data types: Number, S",
        "id": "637bdc110aad625444dc19e1"
      }
    }), ctx.delay(150))
  })
]

const server = setupServer(...handlers)

// Enable API mocking before tests.
beforeAll(() => server.listen())

// Reset any runtime request handlers we may add during the tests.
afterEach(() => server.resetHandlers())

// Disable API mocking after the tests are done.
afterAll(() => server.close())

describe('Testing BlogDetail component', () => {
  it('Fetches & receives a blog details', async () => {
    renderWithProviders(
      (
        <BrowserRouter>
          <BlogDetail />
        </BrowserRouter>
      ), {
      preloadedState: {
        blogs: {
          data: [],
          loading: false,
          isSuccess: false,
          message: "",
          isEditMode: false,
          blogDetail: {
            data: {},
            isSuccess: false,
            loading: false,
            message: ""
          }
        },
        userInfo: {
          loggedIn: false
        }
      }
    })


    /* expect(await screen.findByText(/JavaScript Objects in Detail/i)).toBeInTheDocument()
    expect(await screen.findByText('11/22/2022')).toBeInTheDocument()
    expect(await screen.findByText('Web development')).toBeInTheDocument()


    expect(await screen.findByText(/What is an Object/i)).toBeInTheDocument()
    expect(await screen.findByText(/Serialize and Deserialize Objects/i)).toBeInTheDocument() */

    setTimeout(() => {
      expect(screen.getByText(/JavaScript Objects in Detail/i)).toBeInTheDocument()
      expect(screen.getByText('11/22/2022')).toBeInTheDocument()
      expect(screen.getByText('Web development')).toBeInTheDocument()


      expect(screen.getByText(/What is an Object/i)).toBeInTheDocument()
      expect(screen.getByText(/Serialize and Deserialize Objects/i)).toBeInTheDocument()
    }, 200)
  })
})
